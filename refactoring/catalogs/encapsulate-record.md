# 7.1 캡슐화하기

`Record`자료형을 `Class`로 만들어 데이터의 원본을 숨기고 추상화 하는 기법

```js
// as-is
organization = { name: "애크미 구스베리", country: "GB" };
```

```js
// to-be
class Organization {
  constructor(data) {
    this._name = data.name;
    this._country = data.country;
  }

  get name() { return this._name; }
  set name(arg) { this._name = arg; }
  get country() { return this._country; }
  set country(arg) { this._country = arg;}
}
```

## 설명
### 장점

1. 객체를 사용하면 어떻게 저장했는지를 숨긴 채 원하는 값을 메서드로 제공할 수 있다.
2. 사용자는 원하는 값이 계산된 값인지 원본 값인지 알 필요가 없다.

### 적용 시점

가변 데이터가 계산해서 얻을 수 있는 값과 그렇지 않은 값을 명확하게 구분해서 저장해야 하는 경우에 레코드를 객체로 리팩토링한다.

### 절차

1. 레코드를 담은 변수를 캡슐호 한다.
2. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고, 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다.
3. 테스트한다.
4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.
5. 레코드를 반환하는 예전 함수를 상요하는 코드를 4에서 만든 새 함수를 사용하도록 바꾼다. 필드에 접근할떄는 객체의 접근자를 사용한다. 적절한 접근자가 없다면 추가한다. 한 부분을 바꿀때마다 테스트한다.
    1. 중첩된 구조의 복잡한 레코드라면 먼저 데이터를 갱신하는 클라이언트들을 주의깊게 확인하고 읽기만 하는 부분이라면 읽기전용 객체를 내려주자
6. 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수들을 모두 제거한다.
7. 테스트한다.
8. 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용한다.

## 메모

- 중첩된 코드를 캡슐화 할때는 데이터를 변경하는 부분에 집중하자. 데이터 구조의 안쪽으로 들어가서 변경하는 코드를 `setter`를 작성하여 뽑아낸다. 캡슐화에서는 값을 수정하는 부분을 명확하게 드러내고 한곳에 모아두는것이 중요하기 때문이다.
- 데이터 읽기를 처리하는 방법은 몇 가지가 있다.
    - 읽는 코드를 독립 함수로 추출한다.
        - 장점: 데이터 사용 방법을 모두 확인가능
        - 단점:읽는 패턴이 다양해지면 작성하는 코드 양이 늘어남
    - 실제 데이터를 반환한다.
        - 장점: 간단함.
        - 단점: 클라이언트가 실제 데이터를 바꿀 수가 있다.
            - 클라이언트가 반환된 데이터를 변경하지 못하게 하려면 두가지 방법이 있다.
                - 깊은 복사를 해서 리턴한다.
                - 읽기 전용 `proxy`를 리턴한다.
    - 레코드 캡슐화를 재귀적으로 한다.
        - 장점: 확실하게 모든 부분을 제어할 수 있다.
        - 단점: 작업량이 매우 늘어난다.

### 참고
- 읽기 전용 Proxy를 만드는 법
    - 책에는 js에서는 어렵다고 쓰여 있지만 `es6`에서는 비교적 간단하게 `proxy`를 제공해 줄 수 있다. 단, 이 방법의 단점은 1depth까지만 쓰기 차단을 지원한다는 점이다.

    ```jsx
    const readonlyHandler = {
    	set(target, name, value) {
    		throw new Error("Cannot Assgin value to readonly property");
    	}
    };

    class Data {
    	constructor(data) {
    		this._data = data;
    		this._proxy = new Proxy(this._data, readonlyHandler);
    	}

    	get data() {
    		return this._proxy;
    	}
    }
    ```